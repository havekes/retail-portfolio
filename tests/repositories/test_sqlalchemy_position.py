"""Unit tests for SqlAlchemyPositionRepository."""

from datetime import UTC, datetime
from uuid import uuid4

import pytest
import pytest_asyncio
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.ext.asyncio.engine import AsyncEngine

from src.models import Base
from src.models.account import Account as AccountModel
from src.models.account_type import AccountType as AccountTypeModel
from src.models.institution import Institution as InstitutionModel
from src.models.position import Position as PositionModel
from src.models.security import Security as SecurityModel
from src.models.user import User as UserModel
from src.repositories.sqlalchemy.sqlalchemy_position import (
    SqlAlchemyPositionRepository,
)
from src.schemas.position import Position


@pytest_asyncio.fixture(scope="function")
async def position_test_engine() -> AsyncEngine:
    """Create test database engine for position repository tests."""
    engine = create_async_engine("sqlite+aiosqlite:///:memory:", echo=False)

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    yield engine

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
    await engine.dispose()


@pytest_asyncio.fixture(scope="function")
async def position_db_session(position_test_engine: AsyncEngine) -> AsyncSession:
    """Provide a fresh database session for each test."""
    from sqlalchemy.ext.asyncio import async_sessionmaker  # noqa: PLC0415

    async_session = async_sessionmaker(position_test_engine, expire_on_commit=False)
    async with async_session() as session:
        yield session
        await session.rollback()


@pytest_asyncio.fixture(scope="function")
async def position_repository(
    position_db_session: AsyncSession,
) -> SqlAlchemyPositionRepository:
    """Create a repository instance for testing."""
    return SqlAlchemyPositionRepository(session=position_db_session)


@pytest_asyncio.fixture(scope="function")
async def seed_position_data(position_db_session: AsyncSession) -> tuple:
    """Seed necessary reference data for position tests."""
    # Create user
    user = UserModel(
        id=uuid4(),
        email="posuser@example.com",
        password="hashed",
        is_active=True,
        created_at=datetime.now(UTC),
    )
    position_db_session.add(user)

    # Create account type
    account_type = AccountTypeModel(
        id=1,
        name="TFSA",
        country="CA",
        tax_advantaged=True,
    )
    position_db_session.add(account_type)

    # Create institution
    institution = InstitutionModel(
        id=1,
        name="Wealthsimple",
        country="CA",
        is_active=True,
    )
    position_db_session.add(institution)

    # Create account
    account = AccountModel(
        id=uuid4(),
        external_id="ext_acc",
        name="Position Test Account",
        user_id=user.id,
        account_type_id=account_type.id,
        institution_id=institution.id,
        currency="CAD",
        is_active=True,
        created_at=datetime.now(UTC),
    )
    position_db_session.add(account)

    # Create securities
    security1 = SecurityModel(
        symbol="AAPL",
        name="Apple Inc.",
        sector="Technology",
        industry="Consumer Electronics",
        market_cap=3000000000000.0,
        pe_ratio=25.5,
        is_active=True,
    )

    security2 = SecurityModel(
        symbol="GOOGL",
        name="Alphabet Inc.",
        sector="Technology",
        industry="Internet Services",
        market_cap=1800000000000.0,
        pe_ratio=22.3,
        is_active=True,
    )

    position_db_session.add_all([security1, security2])
    await position_db_session.commit()

    await position_db_session.refresh(user)
    await position_db_session.refresh(account_type)
    await position_db_session.refresh(institution)
    await position_db_session.refresh(account)

    return (user, account, security1, security2)


class TestSqlAlchemyPositionRepository:
    """Test suite for SqlAlchemyPositionRepository."""

    @pytest.mark.asyncio
    async def test_create_position_success(
        self,
        position_repository: SqlAlchemyPositionRepository,
        position_db_session: AsyncSession,
        seed_position_data: tuple,
    ) -> None:
        """Test creating a new position successfully."""
        _, account, security, _ = seed_position_data

        position_schema = Position(
            id=uuid4(),
            account_id=account.id,
            security_symbol=security.symbol,
            quantity=10.5,
            average_cost=150.75,
        )

        result = await position_repository.create_or_update(position_schema)

        # Verify the returned position has correct values
        # Note: The id might be regenerated by ON CONFLICT, so we check other fields
        assert result.account_id == account.id
        assert result.security_symbol == security.symbol
        assert result.quantity == 10.5
        assert result.average_cost == 150.75
        assert isinstance(result, Position)

        # Verify persistence using account_id and security_symbol lookup
        from sqlalchemy import select

        persisted = await position_db_session.execute(
            select(PositionModel).where(
                PositionModel.account_id == account.id,
                PositionModel.security_symbol == security.symbol,
            )
        )
        assert persisted.scalar_one_or_none() is not None

    @pytest.mark.asyncio
    async def test_create_or_update_existing_position(
        self,
        position_repository: SqlAlchemyPositionRepository,
        position_db_session: AsyncSession,
        seed_position_data: tuple,
    ) -> None:
        """Test updating an existing position with create_or_update."""
        _, account, security, _ = seed_position_data
        position_id = uuid4()

        # Create initial position
        position_model = PositionModel(
            id=position_id,
            account_id=account.id,
            security_symbol=security.symbol,
            quantity=10.0,
            average_cost=100.0,
        )
        position_db_session.add(position_model)
        await position_db_session.commit()

        # Update via create_or_update
        updated_position = Position(
            id=position_id,
            account_id=account.id,
            security_symbol=security.symbol,
            quantity=20.0,
            average_cost=110.0,
        )

        result = await position_repository.create_or_update(updated_position)

        # The id might be regenerated depending on ON CONFLICT implementation
        assert result.account_id == account.id
        assert result.security_symbol == security.symbol
        assert result.quantity == 20.0
        assert result.average_cost == 110.0

    @pytest.mark.asyncio
    async def test_create_position_with_no_average_cost(
        self,
        position_repository: SqlAlchemyPositionRepository,
        seed_position_data: tuple,
    ) -> None:
        """Test creating a position without average cost."""
        _, account, security, _ = seed_position_data
        position_id = uuid4()

        position_schema = Position(
            id=position_id,
            account_id=account.id,
            security_symbol=security.symbol,
            quantity=5.0,
            average_cost=None,
        )

        result = await position_repository.create_or_update(position_schema)

        assert result.quantity == 5.0
        assert result.average_cost is None

    @pytest.mark.asyncio
    async def test_get_by_account_single_position(
        self,
        position_repository: SqlAlchemyPositionRepository,
        position_db_session: AsyncSession,
        seed_position_data: tuple,
    ) -> None:
        """Test retrieving positions for an account with one position."""
        _, account, security, _ = seed_position_data

        position_model = PositionModel(
            id=uuid4(),
            account_id=account.id,
            security_symbol=security.symbol,
            quantity=15.0,
            average_cost=200.0,
        )
        position_db_session.add(position_model)
        await position_db_session.commit()

        result = await position_repository.get_by_account(account.id)

        assert len(result) == 1
        assert result[0].security_symbol == security.symbol
        assert result[0].quantity == 15.0
        assert isinstance(result[0], Position)

    @pytest.mark.asyncio
    async def test_get_by_account_multiple_positions(
        self,
        position_repository: SqlAlchemyPositionRepository,
        position_db_session: AsyncSession,
        seed_position_data: tuple,
    ) -> None:
        """Test retrieving multiple positions for an account."""
        _, account, security1, security2 = seed_position_data

        # Create positions for different securities
        for i, security in enumerate([security1, security2]):
            position_model = PositionModel(
                id=uuid4(),
                account_id=account.id,
                security_symbol=security.symbol,
                quantity=10.0 + i,
                average_cost=100.0 + i * 10,
            )
            position_db_session.add(position_model)

        await position_db_session.commit()

        result = await position_repository.get_by_account(account.id)

        assert len(result) == 2
        assert all(p.account_id == account.id for p in result)
        assert {p.security_symbol for p in result} == {"AAPL", "GOOGL"}

    @pytest.mark.asyncio
    async def test_get_by_account_empty_result(
        self,
        position_repository: SqlAlchemyPositionRepository,
        seed_position_data: tuple,
    ) -> None:
        """Test retrieving positions for account with no positions."""
        _, account, _, _ = seed_position_data

        result = await position_repository.get_by_account(account.id)

        assert result == []

    @pytest.mark.asyncio
    async def test_get_by_account_different_accounts(
        self,
        position_repository: SqlAlchemyPositionRepository,
        position_db_session: AsyncSession,
        seed_position_data: tuple,
    ) -> None:
        """Test positions are correctly filtered by account."""
        user, account1, security1, security2 = seed_position_data

        # Create another account
        account_type = await position_db_session.get(AccountTypeModel, 1)
        institution = await position_db_session.get(InstitutionModel, 1)

        account2 = AccountModel(
            id=uuid4(),
            external_id="ext_acc2",
            name="Another Account",
            user_id=user.id,
            account_type_id=account_type.id,
            institution_id=institution.id,
            currency="USD",
            is_active=True,
            created_at=datetime.now(UTC),
        )
        position_db_session.add(account2)
        await position_db_session.commit()

        # Create positions in both accounts
        pos1 = PositionModel(
            id=uuid4(),
            account_id=account1.id,
            security_symbol=security1.symbol,
            quantity=5.0,
            average_cost=100.0,
        )

        pos2 = PositionModel(
            id=uuid4(),
            account_id=account2.id,
            security_symbol=security2.symbol,
            quantity=10.0,
            average_cost=200.0,
        )

        position_db_session.add_all([pos1, pos2])
        await position_db_session.commit()

        result1 = await position_repository.get_by_account(account1.id)
        result2 = await position_repository.get_by_account(account2.id)

        assert len(result1) == 1
        assert result1[0].security_symbol == security1.symbol
        assert len(result2) == 1
        assert result2[0].security_symbol == security2.symbol

    @pytest.mark.asyncio
    async def test_position_returns_schema(
        self,
        position_repository: SqlAlchemyPositionRepository,
        position_db_session: AsyncSession,
        seed_position_data: tuple,
    ) -> None:
        """Test that repository returns Position schema, not model."""
        _, account, security, _ = seed_position_data

        position_model = PositionModel(
            id=uuid4(),
            account_id=account.id,
            security_symbol=security.symbol,
            quantity=25.0,
            average_cost=125.0,
        )
        position_db_session.add(position_model)
        await position_db_session.commit()

        result = await position_repository.get_by_account(account.id)

        assert all(isinstance(p, Position) for p in result)
        assert not any(isinstance(p, PositionModel) for p in result)

    @pytest.mark.asyncio
    async def test_create_or_update_with_float_quantities(
        self,
        position_repository: SqlAlchemyPositionRepository,
        seed_position_data: tuple,
    ) -> None:
        """Test creating positions with various float quantities."""
        _, account, security, _ = seed_position_data

        test_quantities = [0.5, 1.0, 10.25, 100.999, 1000.0001]

        for qty in test_quantities:
            position_schema = Position(
                id=uuid4(),
                account_id=account.id,
                security_symbol=security.symbol,
                quantity=qty,
                average_cost=100.0,
            )

            result = await position_repository.create_or_update(position_schema)
            assert result.quantity == qty

    @pytest.mark.asyncio
    async def test_create_or_update_with_large_average_cost(
        self,
        position_repository: SqlAlchemyPositionRepository,
        seed_position_data: tuple,
    ) -> None:
        """Test creating position with large average cost value."""
        _, account, security, _ = seed_position_data

        large_cost = 999999.99
        position_schema = Position(
            id=uuid4(),
            account_id=account.id,
            security_symbol=security.symbol,
            quantity=1.0,
            average_cost=large_cost,
        )

        result = await position_repository.create_or_update(position_schema)

        assert result.average_cost == large_cost

    @pytest.mark.asyncio
    async def test_create_or_update_multiple_positions_same_security(
        self,
        position_repository: SqlAlchemyPositionRepository,
        position_db_session: AsyncSession,
        seed_position_data: tuple,
    ) -> None:
        """Test creating positions in different accounts with same security."""
        user, account1, security, _ = seed_position_data

        # Create another account
        account_type = await position_db_session.get(AccountTypeModel, 1)
        institution = await position_db_session.get(InstitutionModel, 1)

        account2 = AccountModel(
            id=uuid4(),
            external_id="ext_acc3",
            name="Third Account",
            user_id=user.id,
            account_type_id=account_type.id,
            institution_id=institution.id,
            currency="EUR",
            is_active=True,
            created_at=datetime.now(UTC),
        )
        position_db_session.add(account2)
        await position_db_session.commit()

        # Create positions in both accounts for same security
        pos1_schema = Position(
            id=uuid4(),
            account_id=account1.id,
            security_symbol=security.symbol,
            quantity=20.0,
            average_cost=150.0,
        )

        pos2_schema = Position(
            id=uuid4(),
            account_id=account2.id,
            security_symbol=security.symbol,
            quantity=30.0,
            average_cost=160.0,
        )

        result1 = await position_repository.create_or_update(pos1_schema)
        result2 = await position_repository.create_or_update(pos2_schema)

        assert result1.security_symbol == result2.security_symbol
        assert result1.account_id != result2.account_id
        assert result1.quantity != result2.quantity

    @pytest.mark.asyncio
    async def test_get_by_account_returns_all_fields(
        self,
        position_repository: SqlAlchemyPositionRepository,
        position_db_session: AsyncSession,
        seed_position_data: tuple,
    ) -> None:
        """Test that returned positions have all required fields."""
        _, account, security, _ = seed_position_data

        position_model = PositionModel(
            id=uuid4(),
            account_id=account.id,
            security_symbol=security.symbol,
            quantity=42.5,
            average_cost=333.33,
        )
        position_db_session.add(position_model)
        await position_db_session.commit()

        result = await position_repository.get_by_account(account.id)

        assert len(result) == 1
        position = result[0]

        # Verify all fields exist and have correct types
        assert hasattr(position, "id")
        assert hasattr(position, "account_id")
        assert hasattr(position, "security_symbol")
        assert hasattr(position, "quantity")
        assert hasattr(position, "average_cost")

        assert isinstance(position.id, __import__("uuid").UUID)
        assert isinstance(position.account_id, __import__("uuid").UUID)
        assert isinstance(position.security_symbol, str)
        assert isinstance(position.quantity, float)
